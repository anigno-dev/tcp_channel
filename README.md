# TCP Channel

## This Python script defines a TCP-based communication framework using a custom TcpChannel class. It enables sending and receiving messages between clients and servers over TCP sockets while supporting a callback mechanism for handling incoming data. Here's a breakdown:

Key Components
1. TcpChannel Class
This class handles the core TCP socket operations for sending, receiving, and listening for connections.

Attributes:

BYTES_FOR_DATA_SIZE: Defines the size of the message length header (4 bytes, allowing messages up to ~4GB).
NEXT_READ_BYTES_LENGTH: Controls the buffer size for each read operation.
Sockets (listening_socket, client_socket) and threading objects for listening and receiving data asynchronously.
on_data_received_handler: A callback function invoked when data is received.
Methods:

start_listening(): Starts a thread to listen for incoming client connections.
_start_receiving(): Begins a thread to handle incoming data.
register_data_received_callback(callback): Registers a callback for processing received data.
close(): Gracefully shuts down sockets and terminates threads.
connect(host, port): Establishes a connection to a remote server.
send(data): Sends data, prepending its length as a 4-byte header.
listening_thread_handler(): Thread function for accepting client connections.
data_receiving_thread_handler(): Thread function for reading data from the client.
2. Logging with SimpleLogger
Utilizes the SimpleLogger and custom SeverityPaddingFormatter (from the earlier script) for formatted log output.
Logs activity at various levels (e.g., INFO, DEBUG, ERROR) to track state and errors.
3. Test Functions
The main section includes two tests:

connect_send_receive()
Purpose: Simulates two channels (ch1, ch2) communicating with each other.
Steps:
Initializes two TcpChannel instances (ch1, ch2) on separate ports.
Registers a callback (on_data_received) to log received data and append results to a shared list.
ch1 connects to ch2 and sends large and small data payloads.
Verifies the data received by ch2 matches the expected payloads.
Closes both channels.
connection_error()
Purpose: Simulates a failed connection attempt to test error handling.
Steps:
ch1 starts listening.
Attempts to connect to a non-existent server on another port (9021).
Captures and logs the expected ConnectionRefusedError.
How It Works
Listening for Connections:

A server (ch1) starts listening on a specific port. When a client (ch2) connects, the server logs the connection and starts receiving data in a separate thread.
Sending and Receiving Data:

Data is sent with a 4-byte length prefix, allowing the receiver to read the exact payload size.
Callback Mechanism:

A callback function (on_data_received) processes data when received. It is registered using register_data_received_callback.
Error Handling:

Includes robust error handling for socket operations (OSError, Exception) to prevent crashes from invalid operations or closed sockets.
Important Notes
Concurrency:

Both listening and data-receiving operations run in separate threads, enabling non-blocking behavior.
Data Validation:

The connect_send_receive() test ensures the data is correctly received and verifies message integrity using assertions.
Scalability:

While designed for one-to-one communication, the structure can be extended for multiple clients or a more complex architecture.
Example Output
The logs generated by this script include details such as:

Server and client connections.
Sent and received data sizes.
Errors like connection refusal or socket closure.
This framework is useful for developing lightweight TCP-based communication between components in a distributed system.